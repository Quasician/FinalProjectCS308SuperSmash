In terms of direct API, our project did not have many. However, that is not necessarily because our API was perfect from the start; rather, it was because when we found parts of our API to be insufficient, we would change the implementation rather than the API. This led to several workarounds in the implementation. 

An example of this is with our Controller class. Originally, we planned on only having the control deal with determining whether the game was over and whether the character was out of bounds. However, upon adding collision and keys within the Animation Timer, we realized that the place where we handle the game over condition and the animation would likely end up in the same place. This didn’t seem correct as we didn’t want to have the controller handle animation, but because the logic to determine whether it was game over lived inside of the animation, we made the Controller implement the Animation Timer. This is an example of where we should’ve had an API change, but instead we changed the details of the implementation instead.

One API change we did have, however, was a change to the parameters of isGameOver(), a method declared in the Controller API. We changed the parameter of isGameOver() to take a single boolean value instead of nothing. This boolean is called isLocal and is required by the networked part of the application to determine whether a local game is being played. The isLocal value is required by the GameOver object to determine whether to restart as a multiplayer game or a local game. 

Our API change shows that it may have been better to take into account multiplayer functionality when we were planning our APIs as opposed to trying to add multiplayer at the end. Because of the complicated nature of running a networked game, API changes due to multiplayer were inevitable given that we didn’t account for multiplayer in our initial APIs.
